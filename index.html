<h1 id="introduction">Introduction</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">{-# LANGUAGE DataKinds #-}</span>
<span style="color: green;">{-# LANGUAGE TemplateHaskell #-}</span>
<span style="color: green;">{-# LANGUAGE ConstraintKinds #-}</span>
<span style="color: green;">{-# LANGUAGE FlexibleContexts #-}</span>
<span style="color: green;">{-# LANGUAGE FlexibleInstances #-}</span>
<span style="color: green;">{-# LANGUAGE GADTs #-}</span>
<span style="color: green;">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span style="color: green;">{-# LANGUAGE RankNTypes #-}</span>
<span style="color: green;">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span style="color: green;">{-# LANGUAGE StandaloneKindSignatures #-}</span>
<span style="color: green;">{-# LANGUAGE TypeApplications #-}</span>
<span style="color: green;">{-# LANGUAGE TypeFamilies #-}</span>
<span style="color: green;">{-# LANGUAGE TypeOperators #-}</span>
<span style="color: green;">{-# LANGUAGE UndecidableInstances #-}</span>
<span style="color: green;">{-# LANGUAGE PolyKinds #-}</span>
<span style="color: green;">{-# LANGUAGE AllowAmbiguousTypes #-}</span>
<span style="color: green;">{-# LANGUAGE OverloadedStrings #-}</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">{-# OPTIONS_GHC -Wall -Wno-type-defaults #-}</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Singletons.TH</span> <span style="color: red;">(</span><span style="">genSingletons</span><span style="color: red;">)</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.CoRec</span> <span style="">hiding</span> <span style="color: red;">(</span><span style="">Field</span><span style="color: red;">)</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.Core</span> <span style="">hiding</span> <span style="color: red;">(</span><span style="">rpureConstrained</span><span style="color: red;">,</span> <span style="">rpureConstraints</span><span style="color: red;">)</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Proxy</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.Functor</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.TypeLevel</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.Lens</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.Derived</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Data.Vinyl.Recursive</span> <span style="color: red;">(</span><span style="">rpureConstrained</span><span style="color: red;">)</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">Lens.Micro</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="">GHC.TypeLits</span> <span style="">hiding</span> <span style="color: red;">(</span><span style="">Nat</span><span style="color: red;">)</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">import</span>           <span style="">Frames</span>
<span style="color: blue; font-weight: bold;">import</span>           <span style="">Frames.CSV</span>
<span style="color: blue; font-weight: bold;">import</span>           <span style="">Frames.Melt</span> <span style="color: red;">(</span><span style="">RDeleteAll</span><span style="color: red;">,</span> <span style="">ElemOf</span><span style="color: red;">)</span>
<span style="color: blue; font-weight: bold;">import</span>           <span style="">Data.Vinyl.TypeLevel</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">V</span>
<span style="color: blue; font-weight: bold;">import</span> <span style="color: blue; font-weight: bold;">qualified</span> <span style="">Data.Vinyl</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">V</span></code></pre>
<h1 id="frames-cookbook">Frames Cookbook</h1>
<h2 id="renaming-a-column">Renaming a Column</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">transform</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">rs</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">bs</span> <span style="">.</span> <span style="color: red;">(</span><span style="color: blue; font-weight: bold;">as</span> <span class="hs-sel">⊆</span> <span style="">rs</span><span style="color: red;">,</span> <span style="">RDeleteAll</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">rs</span> <span class="hs-sel">⊆</span> <span style="">rs</span><span style="color: red;">)</span>
             <span style="color: red;">=&gt;</span> <span style="color: red;">(</span><span style="">Record</span> <span style="color: blue; font-weight: bold;">as</span> <span style="color: red;">-&gt;</span> <span style="">Record</span> <span style="">bs</span><span style="color: red;">)</span> <span style="color: red;">-&gt;</span> <span style="">Record</span> <span style="">rs</span> <span style="color: red;">-&gt;</span> <span style="">Record</span> <span style="color: red;">(</span><span style="">RDeleteAll</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">rs</span> <span style="">++</span> <span style="">bs</span><span style="color: red;">)</span>
<span style="">transform</span> <span style="">f</span> <span style="">xs</span> <span style="color: red;">=</span> <span style="">rcast</span> <span style="color: red;">@</span><span style="color: red;">(</span><span style="">RDeleteAll</span> <span style="color: blue; font-weight: bold;">as</span> <span style="">rs</span><span style="color: red;">)</span> <span style="">xs</span> <span style="">`rappend`</span> <span style="">f</span> <span style="color: red;">(</span><span style="">rcast</span> <span style="">xs</span><span style="color: red;">)</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">retypeColumn</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">x</span> <span style="">y</span> <span style="">rs</span> <span style="">.</span> <span style="color: red;">(</span> <span style="">V.KnownField</span> <span style="">x</span>
                                <span style="color: red;">,</span> <span style="">V.KnownField</span> <span style="">y</span>
                                <span style="color: red;">,</span> <span style="">V.Snd</span> <span style="">x</span> <span style="color: red;">~</span> <span style="">V.Snd</span> <span style="">y</span>
                                <span style="color: red;">,</span> <span style="">ElemOf</span> <span style="">rs</span> <span style="">x</span>
                                <span style="color: red;">,</span> <span style="">RDelete</span> <span style="">x</span> <span style="">rs</span> <span class="hs-sel">⊆</span> <span style="">rs</span><span style="color: red;">)</span>
  <span style="color: red;">=&gt;</span> <span style="">Record</span> <span style="">rs</span> <span style="color: red;">-&gt;</span> <span style="">Record</span> <span style="color: red;">(</span><span style="">RDelete</span> <span style="">x</span> <span style="">rs</span> <span style="">V</span><span style="">.++</span> <span style="color: teal;">'</span><span style="color: red;">[</span><span style="">y</span><span style="color: red;">]</span><span style="color: red;">)</span>
<span style="">retypeColumn</span> <span style="color: red;">=</span> <span style="">transform</span> <span style="color: red;">@</span><span style="">rs</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">[</span><span style="">x</span><span style="color: red;">]</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">[</span><span style="">y</span><span style="color: red;">]</span> <span style="color: red;">(</span><span style="color: red;">\</span><span style="">r</span> <span style="color: red;">-&gt;</span> <span style="color: red;">(</span><span style="">rgetField</span> <span style="color: red;">@</span><span style="">x</span> <span style="">r</span> <span style="">&amp;:</span> <span style="">V.RNil</span><span style="color: red;">)</span><span style="color: red;">)</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">PreBenchmarks</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="color: red;">[</span><span style="color: teal;">"Variety"</span> <span style="">:-&gt;</span> <span style="">Text</span><span style="color: red;">,</span> <span style="color: teal;">"Mean"</span> <span style="">:-&gt;</span> <span style="">Double</span><span style="color: red;">]</span>

<span style="">readRec'</span> <span style="color: red;">::</span> <span style="color: red;">(</span><span style="">RMap</span> <span style="">rs</span><span style="color: red;">,</span> <span style="">ReadRec</span> <span style="">rs</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="color: red;">[</span><span style="">Text</span><span style="color: red;">]</span> <span style="color: red;">-&gt;</span> <span style="">Rec</span> <span style="">ElField</span> <span style="">rs</span>
<span style="">readRec'</span> <span style="color: red;">=</span> <span style="">rmap</span> <span style="color: red;">(</span><span style="">either</span> <span style="color: red;">(</span><span style="">error</span> <span style="color: teal;">"Cannot parse"</span><span style="color: red;">)</span> <span style="">id</span> <span style="">.</span> <span style="">getCompose</span><span style="color: red;">)</span> <span style="">.</span> <span style="">readRec</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">rec1</span> <span style="color: red;">::</span> <span style="">Record</span> <span style="">PreBenchmarks</span>
<span style="">rec1</span> <span style="color: red;">=</span> <span style="">readRec'</span> <span style="color: red;">[</span><span style="color: teal;">"Male"</span><span style="color: red;">,</span> <span style="color: teal;">"1.80"</span><span style="color: red;">]</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:t rec1
  rec1 :: Record PreBenchmarks
</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">rec2</span> <span style="color: red;">::</span> <span style="">Record</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Variety"</span><span style="color: red;">,</span> <span style="">Text</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"NewMean"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">rec2</span> <span style="color: red;">=</span> <span style="">retypeColumn</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Mean"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"NewMean"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="">rec1</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:t rec2
  rec2 :: Record '[ '("Variety", Text), '("NewMean", Double)]
</code></pre>
<h2 id="to-be-explained">To Be Explained</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">eitherToMaybe</span> <span style="color: red;">::</span> <span style="color: red;">(</span><span style="">RMap</span> <span style="">rs</span><span style="color: red;">,</span> <span style="">ReadRec</span> <span style="">rs</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="color: red;">[</span><span style="">Text</span><span style="color: red;">]</span> <span style="color: red;">-&gt;</span> <span style="">Rec</span> <span style="color: red;">(</span><span style="">Compose</span> <span style="">Maybe</span> <span style="">ElField</span><span style="color: red;">)</span> <span style="">rs</span>
<span style="">eitherToMaybe</span> <span style="color: red;">=</span> <span style="">rmap</span> <span style="color: red;">(</span><span style="">either</span> <span style="color: red;">(</span><span style="">const</span> <span style="color: red;">(</span><span style="">Compose</span> <span style="">Nothing</span><span style="color: red;">)</span><span style="color: red;">)</span> <span style="color: red;">(</span><span style="">Compose</span> <span style="">.</span> <span style="">Just</span><span style="color: red;">)</span> <span style="">.</span> <span style="">getCompose</span><span style="color: red;">)</span> <span style="">.</span> <span style="">readRec</span></code></pre>
<h1 id="concepts">Concepts</h1>
<p>fields and their types are encoded at the type level in an extensible way. This means that, contrary to static types that Haskell, Aeson etc use, we need some type level collection (type level list), type level functions to check what elements we have in this list, and higher order types (kinds) to define the type of the elements in this list.</p>
<p>type level list of unique identifiers [Name, Age, Height, Weight] :: ’[’Fields]</p>
<pre><code>    vvvvv</code></pre>
<p>type level function Interpretor :: ’Fields -&gt; *</p>
<pre><code>    vvvvv</code></pre>
<p>type level list of concrete data types [String, Int, Double, Double] :: ’[*]</p>
<p>Field Universe “Fields”: This defines a data kind that basically identifies the fields of the record It is later mapped to a concrete type * (e.g. Int or String) through the Interpretor type family (basically a type level function).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">data</span> <span style="">Fields</span> <span style="color: red;">=</span> <span style="">Name</span> <span style="color: red;">|</span> <span style="">Age</span> <span style="color: red;">|</span> <span style="">Height</span> <span style="color: blue; font-weight: bold;">deriving</span> <span style="color: red;">(</span><span style="">Show</span><span style="color: red;">)</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">genSingletons</span> <span style="color: red;">[</span><span style="color: teal;">'</span><span style="color: teal;">'</span><span style="">Fields</span><span style="color: red;">]</span></code></pre>
<p>Interpretor: This is a type family, think type level function, from the Field Universe “Fields” to a concrete type. This Interpretor is also the first type level argument to build a record with the Rec type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="color: blue; font-weight: bold;">family</span> <span style="">Interpretor</span> <span style="color: red;">(</span><span style="">f</span> <span style="color: red;">::</span> <span style="">Fields</span><span style="color: red;">)</span> <span style="color: red;">::</span> <span style="">*</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">Interpretor</span> <span style="">Name</span> <span style="color: red;">=</span> <span style="">String</span>
  <span style="">Interpretor</span> <span style="">Age</span> <span style="color: red;">=</span> <span style="">Int</span>
  <span style="">Interpretor</span> <span style="">Height</span> <span style="color: red;">=</span> <span style="">Double</span></code></pre>
<p>InterpretorType: Type families are not first class in Haskell. This means that they can’t be passed as an argument to another type (e.g. such as we can pass functions to other functions). We work around this limitation with a concrete type that wraps our type family so that we can pass it as an argument to a Rec type. Note that the following type can take an argument that is not of kind * but of kind ’Fields.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">newtype</span> <span style="">InterpretedType</span> <span style="color: red;">(</span><span style="">f</span> <span style="color: red;">::</span> <span style="">Fields</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Itp</span> <span style="color: red;">{</span><span class="hs-sel">_unItp</span> <span style="color: red;">::</span> <span style="">Interpretor</span> <span style="">f</span><span style="color: red;">}</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="color: red;">(</span><span style="">f</span> <span style="color: red;">::</span> <span style="">Fields</span><span style="color: red;">)</span><span style="">.</span> <span style="">Show</span> <span style="color: red;">(</span><span style="">Interpretor</span> <span style="">f</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="">Show</span> <span style="color: red;">(</span><span style="">InterpretedType</span> <span style="">f</span><span style="color: red;">)</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">show</span> <span style="color: red;">(</span><span style="">Itp</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">show</span> <span style="">x</span></code></pre>
<p>We can now build an operator that connects an identifier of kind ’Fields with a value of the associated concrete type as computed by our type level function Interpretor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: red;">(</span><span style="">=::</span><span style="color: red;">)</span> <span style="color: red;">::</span> <span style="">sing</span> <span style="">f</span> <span style="color: red;">-&gt;</span> <span style="">Interpretor</span> <span style="">f</span> <span style="color: red;">-&gt;</span> <span style="">InterpretedType</span> <span style="">f</span>
<span style="color: red;">(</span><span style="">=::</span><span style="color: red;">)</span> <span style="color: blue; font-weight: bold;">_</span> <span style="color: red;">=</span> <span style="">Itp</span></code></pre>
<p>We can now construct an example Vinyl record that associates the type level field identifiers of kind ’Fields with a concrete type via the InterpretedType that is just a box for types derived from the labels via the type family Interpretor</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecord1</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">InterpretedType</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Age</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span>
<span style="">exampleRecord1</span> <span style="color: red;">=</span> <span style="">SAge</span> <span style="">=::</span> <span class="hs-num">20</span> <span style="">:&amp;</span> <span style="">SName</span> <span style="">=::</span> <span style="color: teal;">"Alice"</span> <span style="">:&amp;</span> <span style="">RNil</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecord2</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">InterpretedType</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Height</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span>
<span style="">exampleRecord2</span> <span style="color: red;">=</span> <span style="">SHeight</span> <span style="">=::</span> <span class="hs-num">1.85</span> <span style="">:&amp;</span> <span style="">SName</span> <span style="">=::</span> <span style="color: teal;">"Bob"</span> <span style="">:&amp;</span> <span style="">RNil</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecord3</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">InterpretedType</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span>
<span style="">exampleRecord3</span> <span style="color: red;">=</span> <span style="">SName</span> <span style="">=::</span> <span style="color: teal;">"Bob"</span> <span style="">:&amp;</span> <span style="">RNil</span></code></pre>
<p>simple rappend is just acting on the type level list. Therefore we get duplicate entries. The ++ operator is also a type family.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">composedOverlappingRecord</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">InterpretedType</span> <span style="color: red;">(</span><span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Age</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span> <span style="">++</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Height</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span><span style="color: red;">)</span>
<span style="">composedOverlappingRecord</span> <span style="color: red;">=</span> <span style="">rappend</span> <span style="">exampleRecord1</span> <span style="">exampleRecord2</span></code></pre>
<p>Question: The previous examples with cons :&amp; require all fields to be defined in order. How can I define a record out of order just by type?</p>
<h1 id="functor-games">FUNCTOR GAMES</h1>
<p>exampleRecord with different Interpretor Identity</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">identityRecord</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">Identity</span> <span style="color: teal;">'</span><span style="color: red;">[</span><span style="">Int</span><span style="color: red;">]</span>
<span style="">identityRecord</span> <span style="color: red;">=</span> <span style="">Identity</span> <span class="hs-num">3</span> <span style="">:&amp;</span> <span style="">RNil</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord</span> <span style="color: red;">=</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"height"</span> <span class="hs-num">20.0</span> <span style="">:&amp;</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"age"</span> <span class="hs-num">20</span> <span style="">:&amp;</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"name"</span> <span style="color: teal;">"Charlie"</span> <span style="">:&amp;</span> <span style="">RNil</span></code></pre>
<p>We can build new functors by composing (basically nesting) others with the Compose type. It basically wraps the nested Functors in a new concrete type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MaybeElField</span> <span style="color: red;">=</span> <span style="">Compose</span> <span style="">Maybe</span> <span style="">ElField</span></code></pre>
<p>Functors can be converted into each other. Be careful because this needs to be valid for <em>any</em> x that is stored in them. In other words, you can basically only move <em>everything</em> from one container to the next without changing any value since you don’t know what the value will be. You can also not selectively delete anything. One example where this works is wrapping a value with Maybe. Maybe is just putting all existing values into a new container Just and adds another value Nothing. This can be done for any type whatsoever, which means that we can build a natural transform from any container to Maybe by simply wrapping it in it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">nat1</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">x</span><span style="">.</span> <span style="">ElField</span> <span style="">x</span> <span style="color: red;">-&gt;</span> <span style="">MaybeElField</span> <span style="">x</span>
<span style="">nat1</span> <span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Compose</span> <span style="">$</span> <span style="">Just</span> <span style="">$</span> <span style="">Field</span> <span style="">x</span></code></pre>
<p>We can map such a natural transform over a record as follows:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">mappedOverRecord1</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">MaybeElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">mappedOverRecord1</span> <span style="color: red;">=</span> <span style="">rmap</span> <span style="">nat1</span> <span style="">elFieldRecord</span></code></pre>
<h1 id="lenses">LENSES</h1>
<p>Micro Lens defines the following type synonym for a general getter/setter type Getting r s a = (a -&gt; Const r a) -&gt; s -&gt; Const r s</p>
<p>s stands here for the type of the <em>s</em>tructure, r for the type of the <em>r</em>eturn type, and <em>a</em> for the type within s that we want to modify.</p>
<p>This is what rlens gives us</p>
<p>rlens :: […] =&gt; (f r -&gt; g (f r)) -&gt; record f rs -&gt; g (record f rs)</p>
<p>We can compare this to Getting as follows</p>
<p>s = record f rs : this is the type of the complete structure a = f r : the type of an element within a larger structure. This could, for example, be f=ElField r=’(“height”, Double), r = The return type which is determined by the particular operation we are doing.</p>
<p>For example, the operator “^. :: s -&gt; Getting a s a -&gt; a” is used to simply return the value that belongs to a certain type:</p>
<p>height :: ElField ‘(“height”, Double) height = elFieldRecord ^. rlens @’(“height”, Double)</p>
<p>How can I assign a value of a target field?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord2</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord2</span> <span style="color: red;">=</span> <span style="">elFieldRecord</span> <span style="">&amp;</span> <span style="">rlens</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="">.~</span> <span style="">Field</span> <span class="hs-num">5.0</span></code></pre>
<p>How can I map something over a target field?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord3</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord3</span> <span style="color: red;">=</span> <span style="">elFieldRecord</span> <span style="">&amp;</span> <span style="">rlens</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="">%~</span> <span style="color: red;">(</span><span style="color: red;">\</span><span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">-&gt;</span> <span style="">Field</span> <span style="color: red;">(</span><span class="hs-num">2</span><span style="">*</span><span style="">x</span><span style="color: red;">)</span><span style="color: red;">)</span></code></pre>
<p>How can I change a field to a different type?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord5</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"new height"</span><span style="color: red;">,</span> <span style="">Integer</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord5</span> <span style="color: red;">=</span> <span style="">elFieldRecord</span> <span style="">&amp;</span> <span style="">rlens'</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="">%~</span> <span style="color: red;">(</span><span style="color: red;">\</span><span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">-&gt;</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"new height"</span> <span class="hs-num">19</span><span style="color: red;">)</span></code></pre>
<p>with a helper function</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">rename</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">l'</span> <span style="">l</span> <span style="">v</span><span style="">.</span> <span style="">KnownSymbol</span> <span style="">l'</span> <span style="color: red;">=&gt;</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">l</span><span style="color: red;">,</span> <span style="">v</span><span style="color: red;">)</span> <span style="color: red;">-&gt;</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">l'</span><span style="color: red;">,</span> <span style="">v</span><span style="color: red;">)</span>
<span style="">rename</span> <span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Field</span> <span style="color: red;">@</span><span style="">l'</span> <span style="color: red;">@</span><span style="">v</span> <span style="">x</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord4</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"new name"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord4</span> <span style="color: red;">=</span> <span style="">elFieldRecord</span> <span style="">&amp;</span> <span style="">rlens'</span> <span style="color: red;">@</span><span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="">%~</span> <span style="">rename</span> <span style="color: red;">@</span><span style="color: teal;">"new name"</span></code></pre>
<p>How can I get all ElField’s of a certain type?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">rgetType</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">a</span> <span style="">rs</span> <span style="">rs'</span> <span style="">ss</span><span style="">.</span>
        <span style="color: red;">(</span><span style="">ss</span> <span style="color: red;">~</span> <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="">rs</span><span style="color: red;">,</span> <span style="">RSubset</span> <span style="">ss</span> <span style="">rs</span> <span style="color: red;">(</span><span style="">RImage</span> <span style="">ss</span> <span style="">rs</span><span style="color: red;">)</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span>
        <span style="">Proxy</span> <span style="">a</span> <span style="color: red;">-&gt;</span> <span style="">Rec</span> <span style="">ElField</span> <span style="">rs</span> <span style="color: red;">-&gt;</span> <span style="">Rec</span> <span style="">ElField</span> <span style="">ss</span>
<span style="">rgetType</span> <span style="">p</span> <span style="color: red;">=</span> <span style="">rcast</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">elFieldRecord6</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"new name"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">elFieldRecord6</span> <span style="color: red;">=</span> <span style="">rgetType</span> <span style="color: red;">(</span><span style="">Proxy</span> <span style="color: red;">@</span><span style="">Double</span><span style="color: red;">)</span> <span style="">elFieldRecord4</span></code></pre>
<p>How can I get all field <em>values</em> that are of type x? How can I get all labels for fields that are of type x? How can I get all fields that fullfil a certain constraint? How can I apply a class method to all fields? How can I fold over a list of labels? How can I fold over all records with a certain type? How can I get all fields from a list of types?</p>
<p>MODIFYING RECORDS AT TYPE LEVEL</p>
<p>We will now go through a few functions to Create Read Delete Update records information. Since we defined record fields on the <em>type level</em>, this involves lots of type level functions, aka type families. Consider this type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MyFields</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">]</span></code></pre>
<p>How can we obtain the name of the second column from it? There are two ways, one at the type level, for example useful to define another record with this specific field, and another at run time, for example, to print the label of the second field. Let’s dive into type level first, although it’s a bit more difficult. Here is a first function that gives me a type level number of kind NAT that is the length of the record fields:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">LengthMyType</span> <span style="color: red;">=</span> <span style="">RLength</span> <span style="">MyFields</span></code></pre>
<p>I can check this in ghci (:kind! evaluates type families/synonyms and prints them) with:</p>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! LengthMyType
  LengthMyType :: Nat
  = 'S ('S 'Z)
</code></pre>
<p>The latter indeed means that it’s the successor (S) of the successor (S) of Zero. In other words the number 2.</p>
<p>This type can also be converted to a standard Int runtime value</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">l</span> <span style="color: red;">::</span> <span style="">Int</span>
<span style="">l</span> <span style="color: red;">=</span> <span style="">natToInt</span> <span style="color: red;">@</span><span style="">LengthMyType</span></code></pre>
<p>l correctly prints 2 in ghci</p>
<pre><code><span style="color: gray;">ghci&gt; </span>l
  2
</code></pre>
<p>Next experiment is to recover the index of a certain field:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MyAgeIndex</span> <span style="color: red;">=</span> <span style="">RIndex</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span> <span style="">MyFields</span></code></pre>
<p>This prints</p>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! MyAgeIndex
  MyAgeIndex :: Nat
  = 'S 'Z
</code></pre>
<p>In other words, it recovers the index 1 of this particular field.</p>
<p>We can now try to delete this field from the record</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MyFields2</span> <span style="color: red;">=</span> <span style="">RDelete</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span> <span style="">MyFields</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! MyFields2
  MyFields2 :: [(Symbol, *)]
  = '[ '("name", String)]
</code></pre>
<p>unsurprisingly this worked as well. One more:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MyFields3</span> <span style="color: red;">=</span> <span style="">MyFields</span> <span style="">++</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"weight"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! MyFields3
  MyFields3 :: [(Symbol, *)]
  = '[ '("name", String), '("age", Int), '("height", Double),
       '("weight", Double)]
</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">MyAgeIndex2</span> <span style="color: red;">=</span> <span style="">MapTyCon</span> <span style="">Maybe</span> <span style="">MyFields3</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">AppliedField</span> <span style="color: red;">=</span> <span style="">ApplyToField</span> <span style="">Maybe</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span></code></pre>
<p>get the type of a particular field</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">FieldTypeHeight</span> <span style="color: red;">=</span> <span style="">FieldType</span> <span style="color: teal;">"height"</span> <span style="">MyFields3</span></code></pre>
<p>Questions:</p>
<ul>
<li>How can we recover the index of an ElField only based on the field label? Use case: delete field with a specific label without remembering the whole type. This can be circumvented with a type synonym but that’s a bit less attractive.</li>
</ul>
<p>Here is an example how a field can be recovered simply from the label</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">RecoveredField</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">FieldType</span> <span style="color: teal;">"height"</span> <span style="">MyFields3</span><span style="color: red;">)</span></code></pre>
<p>And here is how we can build a smarter type family that extracts the index of a field just based on the label</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="color: blue; font-weight: bold;">family</span> <span style="">RFieldIndex</span> <span style="color: red;">(</span><span style="">k</span> <span style="color: red;">::</span> <span style="">s</span><span style="color: red;">)</span> <span style="color: red;">(</span><span style="">rs</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="color: red;">(</span><span style="">s</span><span style="color: red;">,</span> <span style="">k2</span><span style="color: red;">)</span><span style="color: red;">]</span><span style="color: red;">)</span> <span style="color: red;">::</span> <span style="">Nat</span> <span style="color: blue; font-weight: bold;">where</span>
       <span style="">RFieldIndex</span> <span style="">k</span> <span style="">rs</span> <span style="color: red;">=</span> <span style="">RIndex</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">k</span><span style="color: red;">,</span> <span style="">FieldType</span> <span style="">k</span> <span style="">rs</span><span style="color: red;">)</span> <span style="">rs</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! RFieldIndex "height" MyFields3</code></pre>
<ul>
<li>How can we recover all fields with a certain type?</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="color: blue; font-weight: bold;">family</span> <span style="">GetAllTypeFields</span> <span style="color: red;">(</span><span style="">a</span> <span style="color: red;">::</span> <span style="">*</span><span style="color: red;">)</span> <span style="color: red;">(</span><span style="">rs</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="color: red;">(</span><span style="">Symbol</span><span style="color: red;">,</span> <span style="">*</span><span style="color: red;">)</span><span style="color: red;">]</span><span style="color: red;">)</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="color: red;">(</span><span style="">Symbol</span><span style="color: red;">,</span> <span style="">*</span><span style="color: red;">)</span><span style="color: red;">]</span> <span style="color: blue; font-weight: bold;">where</span>
        <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="color: red;">(</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">x</span><span style="color: red;">,</span> <span style="">a</span><span style="color: red;">)</span> <span style="color: teal;">'</span><span style="">:</span> <span style="">rs'</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">x</span><span style="color: red;">,</span> <span style="">a</span><span style="color: red;">)</span> <span style="">:</span> <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="">rs'</span>
        <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="color: red;">(</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">x</span><span style="color: red;">,</span> <span style="">b</span><span style="color: red;">)</span> <span style="color: teal;">'</span><span style="">:</span> <span style="">rs'</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="">rs'</span>
        <span style="">GetAllTypeFields</span> <span style="">a</span> <span style="color: teal;">'</span><span style="">[]</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="">[]</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>:kind! GetAllTypeFields Double MyFields3
  GetAllTypeFields Double MyFields3 :: [(Symbol, *)]
  = '[ '("height", Double), '("weight", Double)]
</code></pre>
<p>How can we delete a subset? Use case: remove a set of columns</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="color: blue; font-weight: bold;">family</span> <span style="">RemoveSubset</span> <span style="color: red;">(</span><span style="">ss</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="">k</span><span style="color: red;">]</span><span style="color: red;">)</span> <span style="color: red;">(</span><span style="">rs</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="">k</span><span style="color: red;">]</span><span style="color: red;">)</span> <span style="color: red;">::</span> <span style="color: red;">[</span><span style="">k</span><span style="color: red;">]</span> <span style="color: blue; font-weight: bold;">where</span>
        <span style="">RemoveSubset</span> <span style="color: red;">(</span><span style="">s</span> <span style="color: teal;">'</span><span style="">:</span> <span style="">ss'</span><span style="color: red;">)</span> <span style="">rs</span> <span style="color: red;">=</span> <span style="">RemoveSubset</span> <span style="">ss'</span> <span style="color: red;">(</span><span style="">RDelete</span> <span style="">s</span> <span style="">rs</span><span style="color: red;">)</span>
        <span style="">RemoveSubset</span> <span style="color: teal;">'</span><span style="">[]</span> <span style="">rs</span> <span style="color: red;">=</span> <span style="">rs</span>
        <span style="">RemoveSubset</span> <span style="">ss</span> <span style="color: teal;">'</span><span style="">[]</span> <span style="color: red;">=</span> <span style="color: teal;">'</span><span style="">[]</span></code></pre>
<ul>
<li>How can we recover all fields with a certain constraint?</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">-- type family GetAllConstraintFields (c :: * -&gt; Constraint) (rs :: [(Symbol, *)]) :: [(Symbol, *)] where</span>
<span style="color: green;">--         GetAllConstraintFields c ( '(x, a) ': rs') = '(x, a) : GetAllConstraintFields c rs'</span>
<span style="color: green;">--         GetAllConstraintFields c ( '(x, b) ': rs') = GetAllConstraintFields c rs'</span>
<span style="color: green;">--         GetAllConstraintFields c '[] = '[]</span></code></pre>
<h1 id="playing-with-constraints">PLAYING WITH CONSTRAINTS</h1>
<p>Natural transforms are very limited because we can’t perform actions that depend on the type of the value. We thus still don’t know how to mass-change values in a record because it could hold values of any type and GHC somehow needs to understand what we can and cannot do with them. The way this works is basically via constraints that specify that types have certain interfaces, typeclasses in Haskell. If all types in a record have a Show interface, we can, for example, print them. The following shows an artificial type class Doubler that doubles fields, including String.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">class</span> <span style="">Doubler</span> <span style="">a</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">double</span> <span style="color: red;">::</span> <span style="">a</span> <span style="color: red;">-&gt;</span> <span style="">a</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="">Doubler</span> <span style="">String</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">double</span> <span style="">a</span> <span style="color: red;">=</span> <span style="">a</span> <span style="">&lt;&gt;</span> <span style="">a</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="">Doubler</span> <span style="">Int</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">double</span> <span style="">a</span> <span style="color: red;">=</span> <span class="hs-num">2</span> <span style="">*</span> <span style="">a</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">-- instance Doubler Double where</span>
<span style="color: green;">--   double a = 2 * a</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="color: red;">(</span><span style="">a</span> <span style="color: red;">::</span> <span style="">Fields</span><span style="color: red;">)</span><span style="">.</span> <span style="">Doubler</span> <span style="color: red;">(</span><span style="">Interpretor</span> <span style="">a</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="">Doubler</span> <span style="color: red;">(</span><span style="">InterpretedType</span> <span style="">a</span><span style="color: red;">)</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">double</span> <span style="color: red;">(</span><span style="">Itp</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Itp</span> <span style="">$</span> <span style="">double</span> <span style="">x</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">a</span> <span style="">k</span> <span style="color: red;">(</span><span style="">s</span> <span style="color: red;">::</span> <span style="">Symbol</span><span style="color: red;">)</span><span style="">.</span>
    <span style="color: red;">(</span><span style="">k</span> <span style="color: red;">~</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">s</span><span style="color: red;">,</span> <span style="">a</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="">Doubler</span> <span style="">a</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span>
    <span style="">Doubler</span> <span style="color: red;">(</span><span style="">ElField</span> <span style="">k</span><span style="color: red;">)</span> <span style="color: blue; font-weight: bold;">where</span>
  <span style="">double</span> <span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Field</span> <span style="">$</span> <span style="">double</span> <span style="">x</span></code></pre>
<p>The following is a constraint record. To understand what is going on, it’s helpful to look at the type of the Dict data constructor: Dict :: c a =&gt; a -&gt; Dict c a Whatever gets wrapped in Dict, fullfills the constraint that is given in its first type parameter. If we compose this now with our original InterpretedType, any type has to fullfill this constraint as well. Otherwise we wouldn’t be able to compose. GHC understands this and knows explicitly that each type fullfills the constraint. Here is the composed Functor.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">type</span> <span style="">DoublerTypes</span> <span style="color: red;">=</span> <span style="">Dict</span> <span style="">Doubler</span> <span style="">:.</span> <span style="">InterpretedType</span></code></pre>
<p>And here is how it looks like if we convert a record to one with explicit constraints</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">constraintRecord1</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">DoublerTypes</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Age</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span>
<span style="">constraintRecord1</span> <span style="color: red;">=</span> <span style="">reifyConstraint</span> <span style="color: red;">@</span><span style="">Doubler</span> <span style="">exampleRecord1</span></code></pre>
<p>The following fails</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">-- constraintRecord2 = reifyConstraint @Doubler exampleRecord2</span>
<span style="color: green;">-- with error:</span>
<span style="color: green;">-- • No instance for (Doubler Double)</span>
<span style="color: green;">--    arising from a use of ‘reifyConstraint’</span>
<span style="color: green;">-- because we didn't define a Doubler instance for Double</span></code></pre>
<p>With this new, constraint record, we can use our typeclasses in rmap which is what we wanted in the first place.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">doubled</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">InterpretedType</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="">Age</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="">Name</span><span style="color: red;">]</span>
<span style="">doubled</span> <span style="color: red;">=</span> <span style="">rmap</span> <span style="color: red;">(</span><span style="color: red;">\</span><span style="color: red;">(</span><span style="">Compose</span> <span style="color: red;">(</span><span style="">Dict</span> <span style="">x</span><span style="color: red;">)</span><span style="color: red;">)</span> <span style="color: red;">-&gt;</span> <span style="">double</span> <span style="">x</span><span style="color: red;">)</span> <span style="">constraintRecord1</span></code></pre>
<p>rpure serves to create a record filled with a default. It has type (forall a. f a) -&gt; Rec f a, which means that we need a constructor that works for any (!) type, and even any kind. This is a strong restriction and it essentially limits us to the use of things like Proxy:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecPure1</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">Proxy</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleRecPure1</span> <span style="color: red;">=</span> <span style="">rpure</span> <span style="">Proxy</span></code></pre>
<p>this prints</p>
<pre><code><span style="color: gray;">ghci&gt; </span>exampleRecPure1
  {Proxy, Proxy}
</code></pre>
<p>here is another option</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecPure2</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">MaybeElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleRecPure2</span> <span style="color: red;">=</span> <span style="">rpure</span> <span style="">$</span> <span style="">Compose</span> <span style="">Nothing</span></code></pre>
<p>I can change values in this record now</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecPure3</span> <span style="color: red;">=</span> <span style="">rput</span> <span style="color: red;">(</span><span style="">Compose</span> <span style="">$</span> <span style="">Just</span> <span style="">$</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"name"</span> <span style="color: red;">@</span><span style="">String</span> <span style="color: teal;">"Joe"</span><span style="color: red;">)</span> <span style="">exampleRecPure2</span></code></pre>
<pre><code><span style="color: gray;">ghci&gt; </span>exampleRecPure3
  {Just name :-&gt; "Joe", Nothing, Nothing}
</code></pre>
<p>rpure is thus some kind of equivalent to pure outside of vinyl. Similar to pure that generates a single value list, we here generate a default record.</p>
<p>more useful is often to derive this default value from a typeclass method. However, this can’t be applied to all types, of course but only those who implement the desired typeclass interface. We can express this through a constraint in Haskell. Vinyl provides the function rpureConstrained for this. Look at this fun example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">class</span> <span style="color: red;">(</span><span style="">KnownField</span> <span style="">a</span><span style="color: red;">,</span> <span style="">Monoid</span> <span style="color: red;">(</span><span style="">Snd</span> <span style="">a</span><span style="color: red;">)</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="">Helper</span> <span style="">a</span>
<span style="color: blue; font-weight: bold;">instance</span> <span style="color: red;">(</span><span style="">KnownField</span> <span style="">a</span><span style="color: red;">,</span> <span style="">Monoid</span> <span style="color: red;">(</span><span style="">Snd</span> <span style="">a</span><span style="color: red;">)</span><span style="color: red;">)</span> <span style="color: red;">=&gt;</span> <span style="">Helper</span> <span style="">a</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleRecPure4</span> <span style="color: red;">::</span> <span style="">Rec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"list"</span><span style="color: red;">,</span> <span style="color: red;">[</span><span style="">Double</span><span style="color: red;">]</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"string"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span> <span style="color: red;">]</span>
<span style="">exampleRecPure4</span> <span style="color: red;">=</span> <span style="">rpureConstrained</span> <span style="color: red;">(</span><span style="">Proxy</span> <span style="color: red;">::</span> <span style="">Proxy</span> <span style="">Helper</span><span style="color: red;">)</span> <span style="">f</span>
    <span style="color: blue; font-weight: bold;">where</span>
        <span style="">f</span> <span style="color: red;">::</span> <span style="">Helper</span> <span style="">a</span> <span style="color: red;">=&gt;</span> <span style="">ElField</span> <span style="">a</span>
        <span style="">f</span> <span style="color: red;">=</span> <span style="">Field</span> <span style="">mempty</span></code></pre>
<h1 id="corecords">CoRecords</h1>
<p>Where Records are similar to Product types in Haskell, able to store any <em>combination</em> of values (think AND), CoRecords are similar to standard Sum types and can store any single value but not several at once (think OR). The Co comes from the Categorical notion that a Product is the most “efficient” type that any component can be extracted from, whereas the Sum is the most “efficient” type that any component can be injected in—in this sense they are opposite each other.</p>
<p>Vinyl comes with an extensible CoRec type that is quite similar to a Rec.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec1</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">Identity</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="">Int</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">]</span>
<span style="">exampleCoRec1</span> <span style="color: red;">=</span> <span style="">CoRec</span> <span style="">$</span> <span style="">Identity</span> <span style="color: red;">@</span><span style="">Int</span> <span class="hs-num">3</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec2</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">InterpretedType</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="">Name</span><span style="color: red;">,</span> <span style="">Age</span><span style="color: red;">,</span> <span style="">Height</span><span style="color: red;">]</span>
<span style="">exampleCoRec2</span> <span style="color: red;">=</span> <span style="">CoRec</span> <span style="">$</span> <span style="">Itp</span> <span style="color: red;">@</span><span style="">Name</span> <span style="color: teal;">"Alice"</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec3</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleCoRec3</span> <span style="color: red;">=</span> <span style="">CoRec</span> <span style="">$</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"Name"</span> <span style="color: red;">@</span><span style="">String</span> <span style="color: teal;">"Alice"</span></code></pre>
<p>alternatively one can use the corec smart constructor which helps with type inference when using ElFields.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec4</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Age"</span><span style="color: red;">,</span> <span style="">Int</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Height"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Weight"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleCoRec4</span> <span style="color: red;">=</span> <span style="">corec</span> <span style="color: red;">(</span><span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"Name"</span> <span style="color: teal;">"Bob"</span><span style="color: red;">)</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">a</span> <span style="color: red;">::</span> <span style="">Maybe</span> <span style="color: red;">(</span><span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">)</span>
<span style="">a</span> <span style="color: red;">=</span> <span style="">asA'</span> <span style="">exampleCoRec4</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec5a</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Height1"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span> <span style="color: teal;">"Height2"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleCoRec5a</span> <span style="color: red;">=</span> <span style="">corec</span> <span style="">$</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"Height1"</span> <span class="hs-num">1.85</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec5b</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Name"</span><span style="color: red;">,</span> <span style="">String</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Height1"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span> <span style="color: teal;">"Height2"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleCoRec5b</span> <span style="color: red;">=</span> <span style="">corec</span> <span style="">$</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"Height2"</span> <span class="hs-num">1.90</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">exampleCoRec5c</span> <span style="color: red;">::</span> <span style="">CoRec</span> <span style="">ElField</span> <span style="color: teal;">'</span><span style="color: red;">[</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="color: teal;">"Height1"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">,</span> <span style="color: teal;">'</span><span style="color: red;">(</span> <span style="color: teal;">"Height2"</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span><span style="color: red;">]</span>
<span style="">exampleCoRec5c</span> <span style="color: red;">=</span> <span style="">corec</span> <span style="">$</span> <span style="">Field</span> <span style="color: red;">@</span><span style="color: teal;">"Height2"</span> <span class="hs-num">1.90</span></code></pre>
<p>The following is the approach taken by Frames to use a constraint on CoRec fields</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">class</span> <span style="">ConvertF</span> <span style="">a</span> <span style="color: blue; font-weight: bold;">where</span>
        <span style="">convertF</span> <span style="color: red;">::</span> <span style="">ElField</span> <span style="">a</span> <span style="color: red;">-&gt;</span> <span style="">Maybe</span> <span style="">Double</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: blue; font-weight: bold;">instance</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">s</span><span style="">.</span> <span style="">KnownSymbol</span> <span style="">s</span> <span style="color: red;">=&gt;</span> <span style="">ConvertF</span> <span style="color: teal;">'</span><span style="color: red;">(</span><span style="">s</span><span style="color: red;">,</span> <span style="">Double</span><span style="color: red;">)</span> <span style="color: blue; font-weight: bold;">where</span>
        <span style="">convertF</span> <span style="color: red;">(</span><span style="">Field</span> <span style="">x</span><span style="color: red;">)</span> <span style="color: red;">=</span> <span style="">Just</span> <span style="">x</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">converter</span> <span style="color: red;">::</span> <span style="color: blue; font-weight: bold;">forall</span> <span style="">ts</span><span style="">.</span>
        <span style="">RPureConstrained</span> <span style="">ConvertF</span> <span style="">ts</span> <span style="color: red;">=&gt;</span>
        <span style="">CoRec</span> <span style="">ElField</span> <span style="">ts</span> <span style="color: red;">-&gt;</span> <span style="">Maybe</span> <span style="">Double</span>
<span style="">converter</span> <span style="color: red;">=</span> <span style="">onCoRec</span> <span style="color: red;">@</span><span style="">ConvertF</span> <span style="">convertF</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="">converted1</span> <span style="color: red;">=</span> <span style="">converter</span> <span style="">exampleCoRec5c</span></code></pre>
<p>The following fails on purpose on compile time:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">-- converted2 = converter exampleCoRec5b</span>
<span style="color: green;">--</span>
<span style="color: green;">-- The error is</span>
<span style="color: green;">-- • No instance for (ConvertF '("Name", String))</span>
<span style="color: green;">--     arising from a use of ‘converter’</span></code></pre>
<p>Need to understand RMap and rmap before tackling this. Somehow this relates to morphing one Interpretor into another and it’s unclear to me how this should work</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span style="color: green;">-- combinedOverlappingRecord :: Rec InterpretedType '[ 'Name]</span>
<span style="color: green;">-- combinedOverlappingRecord = rcombine (&lt;&gt;) id id exampleRecord3 exampleRecord3</span></code></pre>
<h1 id="the-corec-type">The CoRec type</h1>
<h1 id="lenses-1">Lenses</h1>
<h1 id="elfields">Elfields</h1>
